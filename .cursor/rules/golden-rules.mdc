---
description: Golden Rules for AI Coding Assistance
globs:
alwaysApply: true
---

# Golden Rules for AI Coding Assistance

For consolidated guidance see [agents/README.md](mdc:../../agents/README.md).
This guide outlines the key principles and practices for AI-assisted development in our SAFe environment.

## Core Principles

1. **File Size Management**

   - Keep files under 500 lines of code
   - Split into modules when approaching limit
   - Maintain clear module boundaries

2. **Conversation Management**

   - Start fresh conversations frequently
   - One task per message for optimal results
   - Avoid long-running threads that degrade quality

3. **Documentation First**

   - Follow documentation hierarchy for updates:
     1. Update working files (.gitignored)
     2. Update task-level documentation
     3. Update story/feature documentation
     4. Update epic-level documentation if needed
     5. Update architectural decisions in ARCHITECTURE.md
     6. Keep README.md current for project-wide changes
   - Write code comments alongside implementation
   - Never delay documentation updates
   - Document discovered tasks in CURRENT_WORK.md

4. **Coding Style**
   - Follow [coding-style.mdc](mdc:.cursor/rules/coding-style.mdc) guidelines
   - **Function Design**: Follow [function-definitions.mdc](mdc:.cursor/rules/function-definitions.mdc) for comprehensive function standards
   - Use dedicated functions for file operations
   - Keep progress tracking separate from core logic

## Project Structure

### Documentation Hierarchy

#### Root Level Documentation (Keep in root)

- `README.md` - Project overview, setup, and maintenance guidelines
- `AGENTS.md` - AI assistant guidance and context
- `GEMINI.md` - Gemini AI workspace context
- `LICENSE` - Project license

#### Project Documentation (`project/`)

- `EPIC-*.md` - Strategic initiatives and business objectives
- `FEATURE-*.md` - Feature scope, constraints, and acceptance criteria
- `STORY-*.md` - User stories with acceptance criteria and implementation notes
- `TASK-*.md` - Technical implementation details and completion criteria

#### Technical Documentation (`docs/`)

- `SETUP.md` - Development environment setup instructions
- `PRODUCT_REQUIREMENTS_DOCUMENT.md` - Product requirements and specifications
- `ARCHITECTURE.md` - System architecture, technical decisions, and constraints

#### Technical Subdirectories (`docs/technical/`)

- Technical implementation details and fixes
- Domain-specific documentation (e.g., `CHUNKING.md`, `EMBEDDING.md`)
- Integration guides and API documentation

#### Project Management (`docs/project/`)

- Project management documentation
- Sprint planning and progress tracking

#### Archive (`docs/archive/`)

- Historical documentation and temporary notes
- Deprecated or outdated documentation

#### Working Documentation (.gitignored)

- `CURRENT_WORK.md` - Active tasks, notes, and immediate TODOs
- `NEXT_DEMO.md` - Features and changes for upcoming demonstration
- `SCRATCH.md` - Temporary notes and experimental ideas (moved to docs/archive/)

### Code Organization

- `src/` - Source code with clear component separation
- `tests/` - All test files (including those previously in root)
- `docs/` - Technical and API documentation
- `.cursor/rules/` - AI assistance rules and guidelines

### File Organization Rules

- **Test Files**: All test files must be placed in `tests/` directory
- **Documentation**: Follow the documentation hierarchy above
- **Root Directory**: Keep only essential project files (README.md, AGENTS.md, GEMINI.md, LICENSE, configuration files)
- **Technical Documentation**: Place in appropriate `docs/` subdirectories
- **Project Management**: Place in `project/` directory structure

## Development Workflow

### 1. Planning Phase

- Review ARCHITECTURE.md at start of new conversations
- Check TASK.md before starting new work
- Update task tracking during development
- Document discovered sub-tasks
- **Create GitHub issues** from STORY-_.md and TASK-_.md files using [github-integration.mdc](mdc:.cursor/rules/github-integration.mdc)

### 2. Implementation Phase

- One task per conversation
- Use test driven development to develop new features
- Write pytest unit tests for the edge cases of each new feature
- Include docstrings and comments in both code and tests for interfaces like function calls, and complex code segments
- Follow coding style guidelines
- Use SOLID principles where applicable, like dependency injection for external interfaces.
- **Follow branch management strategy** with proper naming conventions (feature/, task/, bug/, hotfix/)

### 3. Testing Standards

- Create tests for every new feature
- Test structure:
  - 1 test for expected use
  - edge case tests
  - failure case test for proper error handling
- Mock external service calls
- Update tests when logic changes
- **All pytest tests must pass** before creating pull requests

### 4. GitHub Integration Workflow

- **Issue Management**: Create GitHub issues from project artifacts (STORY-_.md, TASK-_.md)
- **Branch Management**: Use proper naming conventions and creation workflows
- **Pull Request Management**: Follow pre-PR requirements and quality gates
- **Issue Closure**: Update local files and close GitHub issues with completion evidence
- **Quality Gates**: Enforce standards through GitHub Actions integration

#### Git Commit Best Practices

- **Selective Staging**: Always use `git add <specific-file>` to stage only the files that were intentionally changed
- **Never `git add .`**: Avoid staging all changes - this can accidentally include temporary files, logs, or unintended modifications
- **Review Before Commit**: Verify that only the intended files are staged using `git status` before committing
- **Atomic Commits**: Each commit should represent a single logical change with a clear, descriptive message
- **File-Specific Commits**: When making multiple changes, consider separate commits for different types of changes (e.g., code vs. documentation)

## Coding Standards

### General Principles

1. **Readability First**

   - Use clear, descriptive names
   - Follow language-preference rule for code comments
   - Document complex logic with inline comments

2. **Documentation Integration**

   - Link code changes to stories/tasks using IDs
   - Update documentation alongside code changes
   - Add "Reason:" comments for complex logic
   - Follow documentation hierarchy for updates

3. **Quality Gates**
   - Write tests for new functionality
   - Follow TDD where applicable
   - Ensure code coverage meets standards
   - Address technical debt proactively

### Security and Environment

1. **Environment Management**

   - Never trust AI with API keys
   - Implement environment variables manually
   - Use secure configuration patterns
   - Document all required variables

2. **Security Best Practices**

   - Never expose sensitive data
   - Use environment variables for configuration
   - Follow security best practices
   - Document security considerations

3. **Dependency Management**
   - **CRITICAL: Always use `uv add` for project dependencies - NEVER use `pip install`**
   - `pip install` only works locally and causes failures in fresh environments
   - All imported packages must exist in `pyproject.toml` dependencies
   - Before importing: check if package exists, add with `uv add`, then import
   - Use `uv sync` for installing dependencies in fresh environments

## Communication Standards

1. **Code Comments**

   - Follow language-preference rule for English usage
   - Explain complex logic
   - Document assumptions
   - Document decisions
   - Include examples for unclear code

2. **Documentation**
   - Follow markdown standards
   - Keep README files updated
   - Document breaking changes
   - Include setup instructions

## AI Interaction Guidelines

1. **Request Clarity**

   - Be specific in requests
   - Provide relevant examples
   - Include necessary context
   - Specify acceptance criteria

2. **Code Reviews**

   - Follow review checklist
   - Document review findings
   - Track technical debt
   - Ensure documentation updates

3. **AI Behavior Rules**
   - Never assume missing context
   - Ask questions when uncertain
   - Never hallucinate libraries
   - Confirm file paths before use
   - Never delete code without explicit instruction
   - **When adding new imports, always use `uv add package-name` first**
   - **Never suggest `pip install` - always suggest `uv add`**
   - **Verify imported packages exist in `pyproject.toml` before using them**

Remember to update these rules as project standards evolve.
