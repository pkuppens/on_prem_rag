---
description: GitHub integration for issues, pull requests, branches, and project management
alwaysApply: false
---

# GitHub Integration Guide

This rule provides comprehensive GitHub integration capabilities for the On-Premises RAG project, enabling seamless workflow between GitHub issues, pull requests, and the existing SAFe project structure.

**Workflow commands** (delegate to these instead of re-implementing): [/get-started](.cursor/commands/get-started.md) (issues), [/commit](.cursor/commands/commit.md) (commits), [/pr](.cursor/commands/pr.md) (PRs).

## Overview

The GitHub integration extends the existing project management system by:

- Creating GitHub issues from STORY-_.md and TASK-_.md files
- Managing pull requests with proper linking to project artifacts
- Maintaining bidirectional synchronization between GitHub and local documentation
- Supporting branch management and merge workflows
- Enabling issue linking and dependency tracking

## Prerequisites

### GitHub CLI Setup

Install and configure GitHub CLI for programmatic access:

```bash
# Install GitHub CLI (Windows)
winget install GitHub.cli

# Authenticate with GitHub
gh auth login

# Verify authentication
gh auth status
```

### Environment Configuration

Add GitHub configuration to your environment:

```bash
# Add to .env or environment variables
GITHUB_TOKEN=your_personal_access_token
GITHUB_REPO=your_username/on_prem_rag
GITHUB_OWNER=your_username
```

### Required GitHub Permissions

Your GitHub token needs these scopes:

- `repo` (full repository access)
- `issues` (create, read, update issues)
- `pull_requests` (create, read, update pull requests)
- `workflow` (for GitHub Actions integration)

## Issue Management

### Creating Issues from Project Artifacts

#### From User Stories (STORY-\*.md)

```bash
# Create GitHub issue from story file
gh issue create \
  --title "STORY-XXX: [Story Title]" \
  --body-file docs/project/team/stories/STORY-XXX.md \
  --label "story,enhancement" \
  --assignee @me
```

#### From Tasks (TASK-\*.md)

```bash
# Create GitHub issue from task file
gh issue create \
  --title "TASK-XXX: [Task Title]" \
  --body-file docs/project/team/tasks/TASK-XXX.md \
  --label "task,development" \
  --assignee @me
```

### Issue Templates

#### Story Issue Template

```markdown
## User Story

**ID**: STORY-XXX
**Feature**: [FEAT-XXX: Feature Name](../../program/features/FEAT-XXX.md)
**Status**: [Backlog/To Do/In Progress/Review/Done/Blocked]
**Priority**: [P0/P1/P2/P3]
**Points**: [Story Points]

As a **[User Role]**, I want **[capability]**, so that **[benefit]**.

## Acceptance Criteria

- [ ] **Given** [context], **when** [action], **then** [expected result]
- [ ] [Additional criteria...]

## Tasks

- [ ] **[TASK-XXX](../tasks/TASK-XXX.md)**: [Task description]

## Definition of Done

- [ ] [Done criteria 1]
- [ ] [Done criteria 2]

## Links

- **Local Story**: [STORY-XXX.md](docs/project/team/stories/STORY-XXX.md)
- **Feature**: [FEAT-XXX.md](../../program/features/FEAT-XXX.md)
```

#### Task Issue Template

```markdown
## Task Details

**ID**: TASK-XXX
**Story**: [STORY-XXX: Story Title](../stories/STORY-XXX.md)
**Status**: [Todo/In Progress/Review/Done]
**Effort**: [X hours]

## Description

[Clear description of what needs to be done]

## Implementation Hints

- [ ] [Implementation step 1]
- [ ] [Implementation step 2]

## Acceptance Criteria

- [ ] [Specific, measurable criterion 1]
- [ ] [Specific, measurable criterion 2]

## Dependencies

- **Blocked by**: [TASK-XXX or None]
- **Blocks**: [TASK-XXX or None]

## Links

- **Local Task**: [TASK-XXX.md](docs/project/team/tasks/TASK-XXX.md)
- **Parent Story**: [STORY-XXX.md](../stories/STORY-XXX.md)
```

### Issue Management Commands

#### Reading Issues

```bash
# List all open issues
gh issue list --state open

# Get specific issue details
gh issue view ISSUE_NUMBER

# List issues by label
gh issue list --label "story,enhancement"

# Search issues by text
gh issue list --search "STORY-XXX"
```

#### Updating Issues

```bash
# Update issue title
gh issue edit ISSUE_NUMBER --title "New Title"

# Update issue body
gh issue edit ISSUE_NUMBER --body-file updated_description.md

# Add labels
gh issue edit ISSUE_NUMBER --add-label "bug,priority-high"

# Remove labels
gh issue edit ISSUE_NUMBER --remove-label "bug"

# Assign issue
gh issue edit ISSUE_NUMBER --assignee @me

# Close issue
gh issue close ISSUE_NUMBER --comment "Completed as per acceptance criteria"
```

## Role-Based Commit Messages

### Commit Message Format

All commits should follow the role-based format to enable clear handover tracking:

```
[STORY/TASK-ID]: [Role]: [Action] - [Brief Description]
```

### Role-Specific Commit Examples

#### Product Owner Commits

```bash
# Story prioritization and planning
git commit -m "STORY-XXX: Product Owner: move to In Progress - [business justification]"
git commit -m "STORY-XXX: Product Owner: add to Sprint [X] - [priority reason]"
git commit -m "STORY-XXX: Product Owner: handover to Scrum Master - [handover summary]"
```

#### Scrum Master Commits

```bash
# Sprint planning and task delegation
git commit -m "STORY-XXX: Scrum Master: create task breakdown - [task count] tasks created"
git commit -m "STORY-XXX: Scrum Master: assign tasks to team members"
git commit -m "STORY-XXX: Scrum Master: handover to Software Architect - [design focus]"
git commit -m "STORY-XXX: Scrum Master: handover to Software Developer - [implementation focus]"
git commit -m "STORY-XXX: Scrum Master: handover to Software Tester - [testing focus]"
```

#### Software Architect Commits

```bash
# Design and architecture decisions
git commit -m "STORY-XXX: Software Architect: design analysis completed"
git commit -m "STORY-XXX: Software Architect: architecture updated - [summary of changes]"
git commit -m "STORY-XXX: Software Architect: design specification created"
git commit -m "STORY-XXX: Software Architect: handover to Software Developer - [implementation focus]"
```

#### Software Developer Commits

```bash
# Implementation and code development
git commit -m "STORY-XXX: Software Developer: implementation plan created"
git commit -m "STORY-XXX: Software Developer: add unit tests - [test description]"
git commit -m "STORY-XXX: Software Developer: implement [feature description]"
git commit -m "STORY-XXX: Software Developer: code quality improvements - [specific improvements]"
git commit -m "STORY-XXX: Software Developer: handover to Software Tester - [implementation summary]"
```

#### Software Tester Commits

```bash
# Testing and quality assurance
git commit -m "STORY-XXX: Software Tester: test plan created"
git commit -m "STORY-XXX: Software Tester: add functional tests"
git commit -m "STORY-XXX: Software Tester: add integration tests"
git commit -m "STORY-XXX: Software Tester: bug report created - BUG-XXX"
git commit -m "STORY-XXX: Software Tester: handover to Product Owner - [quality summary]"
```

### Handover Tracking

#### Handover Note Creation

Each role should create handover notes in the `tmp/` directory:

```bash
# Create handover note
echo "[Role] handover to [Next Role]:
- [Key Information 1]: [details]
- [Key Information 2]: [details]
- [Key Information 3]: [details]
- [Deadline]: [date]
- [Special Requirements]: [requirements]" > tmp/STORY-XXX-[role]-handover.md

# Commit handover note
git add tmp/STORY-XXX-[role]-handover.md
git commit -m "STORY-XXX: [Role]: handover to [Next Role] - [handover summary]"
git push origin main
```

#### Handover Note Examples

**Product Owner to Scrum Master:**

```bash
echo "STORY-XXX handover to Scrum Master:
- Business Priority: High
- Sprint Target: Sprint 3
- Key Dependencies: TASK-001, TASK-002
- Demo Requirements: Live demo with stakeholders
- Acceptance Criteria: All criteria defined in story file" > tmp/STORY-XXX-po-handover.md
```

**Scrum Master to Software Architect:**

```bash
echo "STORY-XXX handover to Software Architect:
- Design Requirements: API design and database schema
- Technical Constraints: Must integrate with existing auth system
- Architecture Decisions Needed: Caching strategy, error handling
- Integration Points: User service, notification service
- Deadline: Design complete by [date]" > tmp/STORY-XXX-sm-handover.md
```

**Software Architect to Software Developer:**

```bash
echo "STORY-XXX handover to Software Developer:
- Design Specification: docs/technical/STORY-XXX-design.md
- Implementation Guidelines: Follow existing patterns in auth_service/
- Architecture Constraints: Use dependency injection, follow SOLID principles
- Integration Requirements: Mock external services for testing
- Testing Strategy: Unit tests for all public methods
- Code Review Requirements: Architecture compliance check" > tmp/STORY-XXX-architect-handover.md
```

**Software Developer to Software Tester:**

```bash
echo "STORY-XXX handover to Software Tester:
- Implementation Status: All features implemented
- Test Coverage: 85% unit test coverage
- Integration Points: API endpoints, database operations
- Known Issues: None
- Testing Requirements: Functional, integration, and performance testing
- Demo Requirements: API testing with Postman collection" > tmp/STORY-XXX-developer-handover.md
```

**Software Tester to Product Owner:**

```bash
echo "STORY-XXX handover to Product Owner:
- Testing Status: All tests completed
- Quality Assessment: Pass - ready for demo
- Acceptance Criteria: All criteria validated
- Bug Status: 2 minor bugs found and resolved
- Demo Readiness: Ready for stakeholder demo
- Recommendations: Consider adding performance monitoring" > tmp/STORY-XXX-tester-handover.md
```

### Git Workflow Integration

#### Branch Management with Role Tracking

```bash
# Create role-specific branches for handover
git checkout -b feature/STORY-XXX-[role]-work
git push -u origin feature/STORY-XXX-[role]-work

# Work on role-specific tasks
git add .
git commit -m "STORY-XXX: [Role]: [specific work completed]"

# Create handover and merge to main
git checkout main
git merge feature/STORY-XXX-[role]-work
git push origin main
```

#### Handover Verification

```bash
# Verify handover completion
git log --oneline --grep="STORY-XXX.*handover" | head -5

# Check handover notes
ls -la tmp/STORY-XXX-*-handover.md

# Verify role progression
git log --oneline --grep="STORY-XXX" | grep -E "(Product Owner|Scrum Master|Software Architect|Software Developer|Software Tester)"
```

#### Linking Issues

```bash
# Link issues in comments
gh issue comment ISSUE_NUMBER --body "Related to #OTHER_ISSUE_NUMBER"

# Create issue dependencies
gh issue comment ISSUE_NUMBER --body "Depends on: #BLOCKING_ISSUE_NUMBER"
```

## Pull Request Management

### Pre-PR Requirements

Before creating any pull request, ensure the following requirements are met:

#### 1. Pytest Tests Must Pass

**CRITICAL**: All pytest tests must pass before creating a pull request. This is enforced by GitHub Actions.

```bash
# Run all tests locally before creating PR
uv run pytest -v

# Run tests excluding slow and internet-dependent tests (matches CI)
uv run pytest -m "not internet and not slow" -v

# Run with coverage to ensure good test coverage
uv run pytest --cov=src/backend --cov-report=term-missing
```

**Failure to pass tests will result in PR rejection by GitHub Actions.**

#### 2. Code Quality Checks

```bash
# Lint with ruff (must pass)
uv run ruff check .

# Format check (must pass)
uv run ruff format --check .

# Fix formatting issues if needed
uv run ruff format .
```

#### 3. Documentation Updates

- [ ] Update relevant technical documentation
- [ ] Update task/story files with completion status
- [ ] Add code comments for complex logic
- [ ] Update README if needed

#### 4. Pre-PR Checklist

- [ ] All tests pass (`uv run pytest -v`)
- [ ] Code is properly formatted (`uv run ruff format --check .`)
- [ ] No linting errors (`uv run ruff check .`)
- [ ] Documentation is updated
- [ ] Task/story acceptance criteria are met
- [ ] Code follows [coding-style.mdc](.cursor/rules/coding-style.mdc) guidelines

### Creating Pull Requests

#### From Feature Branches

```bash
# Create PR from current branch
gh pr create \
  --title "FEAT-XXX: [Feature Title]" \
  --body-file pr_description.md \
  --label "feature,enhancement" \
  --assignee @me \
  --reviewer @reviewer_username
```

#### From Task Branches

```bash
# Create PR for specific task
gh pr create \
  --title "TASK-XXX: [Task Title]" \
  --body "Implements TASK-XXX as defined in [TASK-XXX.md](docs/project/team/tasks/TASK-XXX.md)" \
  --label "task,development" \
  --assignee @me
```

### Pull Request Templates

#### Feature PR Template

```markdown
## Feature Implementation

**Feature**: [FEAT-XXX: Feature Title](../../program/features/FEAT-XXX.md)
**Related Stories**:

- [STORY-XXX: Story Title](../../team/stories/STORY-XXX.md)

## Changes Made

- [ ] [Change 1]
- [ ] [Change 2]

## Testing

- [ ] **Pytest tests pass** (`uv run pytest -v`) - **REQUIRED**
- [ ] Unit tests added/updated
- [ ] Integration tests pass
- [ ] Manual testing completed
- [ ] Code coverage maintained/improved

## Documentation

- [ ] Code comments added
- [ ] Technical documentation updated
- [ ] User documentation updated

## Checklist

- [ ] Code follows [coding-style.mdc](.cursor/rules/coding-style.mdc) guidelines
- [ ] Tests follow [test-documentation.mdc](.cursor/rules/test-documentation.mdc) standards
- [ ] Documentation follows [markdown.mdc](.cursor/rules/markdown.mdc) format
- [ ] All acceptance criteria met
- [ ] Ready for review

## Links

- **Feature**: [FEAT-XXX.md](../../program/features/FEAT-XXX.md)
- **Related Issues**: #ISSUE_NUMBER
```

#### Task PR Template

```markdown
## Task Implementation

**Task**: [TASK-XXX: Task Title](../../team/tasks/TASK-XXX.md)
**Story**: [STORY-XXX: Story Title](../../team/stories/STORY-XXX.md)

## Implementation Details

[Description of what was implemented]

## Acceptance Criteria Status

- [x] [Criterion 1] - ✅ Completed
- [x] [Criterion 2] - ✅ Completed

## Testing

- [ ] **Pytest tests pass** (`uv run pytest -v`) - **REQUIRED**
- [ ] Unit tests added/updated
- [ ] Manual testing completed
- [ ] Edge cases tested
- [ ] Code coverage maintained/improved

## Documentation

- [ ] Code comments added
- [ ] Task documentation updated

## Checklist

- [ ] Implementation follows task requirements
- [ ] Code quality standards met
- [ ] All acceptance criteria satisfied
- [ ] Ready for review

## Links

- **Task**: [TASK-XXX.md](../../team/tasks/TASK-XXX.md)
- **Parent Story**: [STORY-XXX.md](../../team/stories/STORY-XXX.md)
- **Related Issue**: #ISSUE_NUMBER
```

### Pull Request Management Commands

#### Reading PRs

```bash
# List open pull requests
gh pr list --state open

# Get specific PR details
gh pr view PR_NUMBER

# List PRs by label
gh pr list --label "feature,enhancement"

# Get PR diff
gh pr diff PR_NUMBER
```

#### Updating PRs

```bash
# Update PR title
gh pr edit PR_NUMBER --title "New Title"

# Update PR body
gh pr edit PR_NUMBER --body-file updated_description.md

# Add reviewers
gh pr edit PR_NUMBER --add-reviewer @reviewer_username

# Add labels
gh pr edit PR_NUMBER --add-label "ready-for-review"

# Merge PR
gh pr merge PR_NUMBER --merge --delete-branch
```

## Branch Management

### Creating Branches

#### Feature Branches

**Default — from main**:

```bash
# Create feature branch from main
git checkout main
git pull origin main
git checkout -b feature/FEAT-XXX-short-description

# Push and set upstream
git push -u origin feature/FEAT-XXX-short-description
```

**Branch off non-main** (when the issue requires tooling from an unmerged branch, e.g. commands or rules):

```bash
# Create feature branch from workflow-improvements (or other base)
git checkout feature/workflow-improvements
git pull origin feature/workflow-improvements
git checkout -b feature/85-short-description

# Push and set upstream
git push -u origin feature/85-short-description
```

When using a non-main base, the PR targets that base branch (e.g. `feature/workflow-improvements`) until it is merged; then follow-up PRs can target main.

#### Task Branches

```bash
# Create task branch from feature branch
git checkout feature/FEAT-XXX-short-description
git pull origin feature/FEAT-XXX-short-description
git checkout -b task/TASK-XXX-short-description

# Push and set upstream
git push -u origin task/TASK-XXX-short-description
```

### Branch Naming Conventions

- **Features**: `feature/FEAT-XXX-short-description`
- **Tasks**: `task/TASK-XXX-short-description`
- **Bugs**: `bug/BUG-XXX-short-description`
- **Hotfixes**: `hotfix/HOTFIX-XXX-short-description`

### Branch Management Commands

```bash
# List all branches
git branch -a

# Delete local branch
git branch -d branch-name

# Delete remote branch
git push origin --delete branch-name

# Switch to branch
git checkout branch-name

# Create and switch to new branch
git checkout -b new-branch-name
```

## GitHub Actions Integration

### Automated Quality Gates

The project uses GitHub Actions to enforce quality standards before PRs can be merged:

#### CI/CD Pipeline (`.github/workflows/python-ci.yml`)

**Triggers**:

- Push to `main` branch
- Pull requests to `main` branch

**Quality Gates**:

1. **Dependency Installation**: Uses `uv sync --dev` for proper dependency management
2. **Model Caching**: Pre-downloads embedding models for consistent testing
3. **Linting**: Runs `ruff check` and `ruff format --check`
4. **Testing**: Runs pytest with markers `-m "not internet and not slow"`
5. **Security Scanning**: Bandit and Safety vulnerability checks
6. **Parallel Execution**: Lint, model-download, and test jobs run in parallel
7. **Advanced Caching**: UV dependencies, HuggingFace models, and pytest cache
8. **Comprehensive Reporting**: JUnit XML, coverage reports, and CI summary dashboard

**Failure Behavior**:

- PRs with failing tests are automatically blocked
- PRs with linting errors are automatically blocked
- PRs with formatting issues are automatically blocked

#### Local Development Workflow

```bash
# 1. Before creating PR, run full test suite
uv run pytest -v

# 2. Check code quality
uv run ruff check .
uv run ruff format --check .

# 3. Fix any issues
uv run ruff format .  # Auto-fix formatting
# Fix linting issues manually

# 4. Create PR only after all checks pass
gh pr create --title "TASK-XXX: [Description]" --body-file pr_description.md
```

#### Bypassing Quality Gates

**Not Recommended**: Quality gates should not be bypassed. If tests are failing:

1. **Fix the failing tests** - Update test code to match implementation
2. **Fix the implementation** - Update code to pass existing tests
3. **Add missing tests** - Write tests for new functionality
4. **Update test markers** - Mark slow/internet tests appropriately

## Workflow Integration

### SAFe Integration Workflow

#### 1. Epic to Feature to Story to Task

```bash
# 1. Create feature branch from epic
git checkout -b feature/FEAT-XXX-from-epic

# 2. Create GitHub issue for feature
gh issue create --title "FEAT-XXX: [Feature Title]" --body-file docs/project/program/features/FEAT-XXX.md

# 3. Create story branches from feature
git checkout -b story/STORY-XXX-from-feature

# 4. Create GitHub issue for story
gh issue create --title "STORY-XXX: [Story Title]" --body-file docs/project/team/stories/STORY-XXX.md

# 5. Create task branches from story
git checkout -b task/TASK-XXX-from-story

# 6. Create GitHub issue for task
gh issue create --title "TASK-XXX: [Task Title]" --body-file docs/project/team/tasks/TASK-XXX.md
```

#### 2. Development Workflow

```bash
# 1. Work on task
git add .
git commit -m "TASK-XXX: Implement [specific functionality]"

# 2. Push changes
git push origin task/TASK-XXX-from-story

# 3. Create PR for task
gh pr create --title "TASK-XXX: [Task Title]" --body "Implements TASK-XXX"

# 4. After review and merge, update task status
gh issue close TASK_ISSUE_NUMBER --comment "Task completed and merged"
```

#### 3. Story Completion Workflow

```bash
# 1. Merge all task PRs into story branch
git checkout story/STORY-XXX-from-feature
git merge task/TASK-XXX-from-story

# 2. Create PR for story
gh pr create --title "STORY-XXX: [Story Title]" --body "Implements STORY-XXX"

# 3. After review and merge, update story status
gh issue close STORY_ISSUE_NUMBER --comment "Story completed and merged"
```

### Issue Linking and Dependencies

#### Creating Issue Dependencies

```bash
# Link task issue to story issue
gh issue comment TASK_ISSUE_NUMBER --body "Parent story: #STORY_ISSUE_NUMBER"

# Link story issue to feature issue
gh issue comment STORY_ISSUE_NUMBER --body "Part of feature: #FEATURE_ISSUE_NUMBER"

# Create blocking relationship
gh issue comment BLOCKED_ISSUE_NUMBER --body "Blocked by: #BLOCKING_ISSUE_NUMBER"
```

#### Issue Status Management

````bash
# Update issue status with labels
gh issue edit ISSUE_NUMBER --add-label "in-progress"
gh issue edit ISSUE_NUMBER --remove-label "todo"

# Close issue with completion comment using temp file
TIMESTAMP=$(date +"%Y-%m-%dT%H-%M-%S")
COMMENT_FILE="tmp/github/issue-comments/issue-${ISSUE_NUMBER}-${TIMESTAMP}.md"

cat > "$COMMENT_FILE" << 'EOF'
## ✅ Task Completion Verified

**Implementation Status**: COMPLETED
**Verification Date**: $(date)
**Task ID**: TASK-XXX

**Evidence of Completion**:
```bash
# Test the implementation
uv run pytest tests/test_qa_system.py::TestQASystem::test_qa_system_initialization -v
# Expected: PASSED

# Verify file exists
ls -la src/backend/rag_pipeline/api/ask.py
# Expected: File exists with recent timestamp
````

**Acceptance Criteria Met**:

- ✅ [Criterion 1]
- ✅ [Criterion 2]

**Local Documentation Updated**: ✅
**Ready for Closure**: ✅
EOF

gh issue comment "$ISSUE_NUMBER" --body-file "$COMMENT_FILE"
gh issue close "$ISSUE_NUMBER" --comment "Task completed and verified with evidence. All acceptance criteria met."

````

## Task Completion Verification

### Automated Task Completion Check

```bash
#!/bin/bash
# verify_task_completion.sh

TASK_ID=$1
GITHUB_ISSUE_NUMBER=$2

if [ -z "$TASK_ID" ] || [ -z "$GITHUB_ISSUE_NUMBER" ]; then
    echo "Usage: $0 <TASK_ID> <GITHUB_ISSUE_NUMBER>"
    echo "Example: $0 TASK-010 47"
    exit 1
fi

# Check if task file exists
TASK_FILE="docs/project/team/tasks/$TASK_ID.md"
if [ ! -f "$TASK_FILE" ]; then
    echo "Task file not found: $TASK_FILE"
    exit 1
fi

# Check if implementation files exist based on task
case $TASK_ID in
    "TASK-010")
        # Check for API endpoint implementation
        if [ -f "src/backend/rag_pipeline/api/ask.py" ]; then
            echo "✅ TASK-010 implementation found: ask.py"
            # Update local task file
            sed -i 's/- \[ \] Endpoint returns HTTP 200/- [x] Endpoint returns HTTP 200/' "$TASK_FILE"
            sed -i 's/- \[ \] Invalid input returns HTTP 400/- [x] Invalid input returns HTTP 400/' "$TASK_FILE"
            sed -i 's/\*\*Status\*\*: Todo/\*\*Status\*\*: Completed/' "$TASK_FILE"
            echo "Updated local task file: $TASK_FILE"
        else
            echo "❌ TASK-010 implementation not found"
            exit 1
        fi
        ;;
    "TASK-011")
        # Check for vector search implementation
        if [ -f "src/backend/rag_pipeline/core/qa_system.py" ]; then
            echo "✅ TASK-011 implementation found: qa_system.py"
            # Update local task file
            sed -i 's/- \[ \] Retrieval returns top N chunks/- [x] Retrieval returns top N chunks/' "$TASK_FILE"
            sed -i 's/- \[ \] Configurable similarity threshold/- [x] Configurable similarity threshold/' "$TASK_FILE"
            sed -i 's/\*\*Status\*\*: Todo/\*\*Status\*\*: Completed/' "$TASK_FILE"
            echo "Updated local task file: $TASK_FILE"
        else
            echo "❌ TASK-011 implementation not found"
            exit 1
        fi
        ;;
    "TASK-012")
        # Check for LLM integration
        if grep -q "generate_answer" "src/backend/rag_pipeline/core/llm_providers.py"; then
            echo "✅ TASK-012 implementation found: llm_providers.py"
            # Update local task file
            sed -i 's/- \[ \] Function accepts question and context/- [x] Function accepts question and context/' "$TASK_FILE"
            sed -i 's/- \[ \] Errors from the LLM service/- [x] Errors from the LLM service/' "$TASK_FILE"
            sed -i 's/\*\*Status\*\*: Todo/\*\*Status\*\*: Completed/' "$TASK_FILE"
            echo "Updated local task file: $TASK_FILE"
        else
            echo "❌ TASK-012 implementation not found"
            exit 1
        fi
        ;;
    *)
        echo "Unknown task ID: $TASK_ID"
        exit 1
        ;;
esac

# Create temp file for GitHub comment with evidence
TIMESTAMP=$(date +"%Y-%m-%dT%H-%M-%S")
mkdir -p "tmp/github/issue-comments"
COMMENT_FILE="tmp/github/issue-comments/issue-${GITHUB_ISSUE_NUMBER}-${TIMESTAMP}.md"

# Collect evidence based on task type
case $TASK_ID in
    "TASK-010")
        IMPLEMENTATION_FILE="src/backend/rag_pipeline/api/ask.py"
        TEST_COMMAND="uv run pytest tests/test_qa_system.py::TestAskAPI -v"
        ;;
    "TASK-011")
        IMPLEMENTATION_FILE="src/backend/rag_pipeline/core/qa_system.py"
        TEST_COMMAND="uv run pytest tests/test_qa_system.py::TestQASystem -v"
        ;;
    "TASK-012")
        IMPLEMENTATION_FILE="src/backend/rag_pipeline/core/llm_providers.py"
        TEST_COMMAND="uv run pytest tests/test_qa_system.py::TestOllamaProvider -v"
        ;;
esac

# Create comment with evidence
cat > "$COMMENT_FILE" << EOF
## ✅ Task Completion Verified

**Implementation Status**: COMPLETED
**Verification Date**: $(date)
**Task ID**: $TASK_ID

**Files Implemented**:
- \`$IMPLEMENTATION_FILE\` - $(case $TASK_ID in
    "TASK-010") echo "FastAPI endpoint implementation" ;;
    "TASK-011") echo "Vector search retrieval logic" ;;
    "TASK-012") echo "Ollama LLM integration" ;;
esac)

**Evidence of Completion**:
\`\`\`bash
# Test the implementation
$TEST_COMMAND
# Expected: All tests PASSED

# Verify file exists and is recent
ls -la $IMPLEMENTATION_FILE
# Expected: File exists with recent timestamp

# Check file size (should be > 0)
wc -l $IMPLEMENTATION_FILE
# Expected: File has content
\`\`\`

**Acceptance Criteria Met**:
$(grep -A 10 "## Acceptance Criteria" "$TASK_FILE" | grep "\[x\]" | sed 's/- \[x\]/- ✅/')

**Local Documentation Updated**: ✅
**Ready for Closure**: ✅
EOF

# Use temp file for GitHub comment
gh issue comment "$GITHUB_ISSUE_NUMBER" --body-file "$COMMENT_FILE"

# Close the issue
gh issue close "$GITHUB_ISSUE_NUMBER" --comment "Task completed and verified with evidence. All acceptance criteria met."
echo "Closed GitHub issue #$GITHUB_ISSUE_NUMBER"
````

### Story Completion Verification

```bash
#!/bin/bash
# verify_story_completion.sh

STORY_ID=$1
GITHUB_ISSUE_NUMBER=$2

if [ -z "$STORY_ID" ] || [ -z "$GITHUB_ISSUE_NUMBER" ]; then
    echo "Usage: $0 <STORY_ID> <GITHUB_ISSUE_NUMBER>"
    echo "Example: $0 STORY-003 46"
    exit 1
fi

STORY_FILE="docs/project/team/stories/$STORY_ID.md"
if [ ! -f "$STORY_FILE" ]; then
    echo "Story file not found: $STORY_FILE"
    exit 1
fi

# Check if all tasks are completed
TASK_COUNT=$(grep -c "TASK-" "$STORY_FILE")
COMPLETED_TASKS=$(grep -c "\[x\]" "$STORY_FILE")

echo "Story: $STORY_ID"
echo "Total tasks: $TASK_COUNT"
echo "Completed tasks: $COMPLETED_TASKS"

if [ "$TASK_COUNT" -eq "$COMPLETED_TASKS" ]; then
    echo "✅ All tasks completed for story $STORY_ID"

    # Update story status
    sed -i 's/\*\*Status\*\*: In Progress/\*\*Status\*\*: Completed/' "$STORY_FILE"
    echo "Updated story status to Completed"

    # Create temp file for GitHub comment with evidence
    TIMESTAMP=$(date +"%Y-%m-%dT%H-%M-%S")
    mkdir -p "tmp/github/issue-comments"
    COMMENT_FILE="tmp/github/issue-comments/issue-${GITHUB_ISSUE_NUMBER}-${TIMESTAMP}.md"

    # Create comment with evidence
    cat > "$COMMENT_FILE" << EOF
## ✅ Story Completion Verified

**Story Status**: COMPLETED
**Verification Date**: $(date)
**Tasks Completed**: $COMPLETED_TASKS/$TASK_COUNT

**Evidence of Completion**:
\`\`\`bash
# Run comprehensive test suite
uv run pytest tests/test_qa_system.py -v
# Expected: All tests PASSED

# Verify all implementation files exist
ls -la src/backend/rag_pipeline/api/ask.py
ls -la src/backend/rag_pipeline/core/qa_system.py
ls -la src/backend/rag_pipeline/core/llm_providers.py
# Expected: All files exist with recent timestamps

# Check test coverage
uv run pytest tests/test_qa_system.py --cov=src/backend/rag_pipeline --cov-report=term-missing
# Expected: Good test coverage
\`\`\`

**All Acceptance Criteria Met**:
$(grep -A 10 "## Acceptance Criteria" "$STORY_FILE" | grep "\[x\]" | sed 's/- \[x\]/- ✅/')

**Definition of Done Met**:
$(grep -A 10 "## Definition of Done" "$STORY_FILE" | grep "\[x\]" | sed 's/- \[x\]/- ✅/')

**Local Documentation Updated**: ✅
**Ready for Closure**: ✅
EOF

    # Use temp file for GitHub comment
    gh issue comment "$GITHUB_ISSUE_NUMBER" --body-file "$COMMENT_FILE"

    gh issue close "$GITHUB_ISSUE_NUMBER" --comment "Story completed and verified with evidence. All tasks and acceptance criteria met."
    echo "Closed GitHub issue #$GITHUB_ISSUE_NUMBER"
else
    echo "❌ Not all tasks completed for story $STORY_ID"
    echo "Remaining tasks: $((TASK_COUNT - COMPLETED_TASKS))"
    exit 1
fi
```

## Automation Scripts

### Create Issue from Project File

```bash
#!/bin/bash
# create_issue_from_file.sh

FILE_PATH=$1
ISSUE_TYPE=$2

if [ -z "$FILE_PATH" ] || [ -z "$ISSUE_TYPE" ]; then
    echo "Usage: $0 <file_path> <issue_type>"
    echo "Issue types: story, task, feature"
    exit 1
fi

# Extract ID from filename
ID=$(basename "$FILE_PATH" .md)

# Create issue based on type
case $ISSUE_TYPE in
    "story")
        gh issue create --title "$ID: $(grep '^# User Story:' "$FILE_PATH" | cut -d':' -f2- | xargs)" --body-file "$FILE_PATH" --label "story,enhancement"
        ;;
    "task")
        gh issue create --title "$ID: $(grep '^# Task:' "$FILE_PATH" | cut -d':' -f2- | xargs)" --body-file "$FILE_PATH" --label "task,development"
        ;;
    "feature")
        gh issue create --title "$ID: $(grep '^# Feature:' "$FILE_PATH" | cut -d':' -f2- | xargs)" --body-file "$FILE_PATH" --label "feature,enhancement"
        ;;
    *)
        echo "Invalid issue type. Use: story, task, feature"
        exit 1
        ;;
esac
```

### Sync Project Status with GitHub

```bash
#!/bin/bash
# sync_project_status.sh

# Update all open issues with current project status
gh issue list --state open --json number,title,labels --jq '.[] | select(.labels[].name == "story" or .labels[].name == "task") | .number' | while read -r issue_number; do
    # Get issue details
    issue_title=$(gh issue view "$issue_number" --json title --jq '.title')

    # Extract ID from title
    id=$(echo "$issue_title" | grep -o '^[A-Z]*-[0-9]*')

    # Find corresponding project file
    if [[ $id == STORY-* ]]; then
        project_file="docs/project/team/stories/$id.md"
    elif [[ $id == TASK-* ]]; then
        project_file="docs/project/team/tasks/$id.md"
    fi

    if [ -f "$project_file" ]; then
        # Update issue body with current project file content
        gh issue edit "$issue_number" --body-file "$project_file"
        echo "Updated issue $issue_number with content from $project_file"
    fi
done
```

## Integration with Existing Rules

### Project Management Integration

This GitHub integration rule works seamlessly with:

- [project-management.mdc](mdc:.cursor/rules/project-management.mdc): SAFe methodology and task management
- [story-template.mdc](mdc:.cursor/rules/story-template.mdc): User story structure and templates
- [task-template.mdc](mdc:.cursor/rules/task-template.mdc): Task structure and templates

### Documentation Integration

- [documentation-code-sync.mdc](mdc:.cursor/rules/documentation-code-sync.mdc): Bidirectional references between code and documentation
- [markdown.mdc](mdc:.cursor/rules/markdown.mdc): Documentation formatting standards

### Development Standards

- [coding-style.mdc](mdc:.cursor/rules/coding-style.mdc): Code quality and style guidelines
- [test-documentation.mdc](mdc:.cursor/rules/test-documentation.mdc): Testing standards and documentation
- [dependency-management.mdc](mdc:.cursor/rules/dependency-management.mdc): Package management with `uv`

## Best Practices

### Issue Management

1. **Always link issues to project files**: Include links to corresponding STORY-_.md or TASK-_.md files using full GitHub URLs
2. **Use consistent labeling**: Apply appropriate labels for filtering and organization
3. **Update status regularly**: Keep issue status synchronized with project file status
4. **Close with context**: Include completion details when closing issues
5. **Maintain checkbox integrity**: Update local markdown checkboxes when tasks are completed
6. **Verify completion**: Check implementation before marking tasks as complete

### Pull Request Management

1. **Link to project artifacts**: Always reference related stories, tasks, or features
2. **Use templates**: Follow PR templates for consistent documentation
3. **Include acceptance criteria**: Reference and verify acceptance criteria completion
4. **Update documentation**: Ensure all related documentation is updated

### Branch Management

1. **Follow naming conventions**: Use consistent branch naming patterns
2. **Keep branches focused**: One feature/story/task per branch
3. **Clean up after merge**: Delete merged branches to maintain repository hygiene
4. **Use descriptive commit messages**: Include project IDs in commit messages

### Workflow Integration

1. **Maintain bidirectional sync**: Keep GitHub issues and local project files synchronized
2. **Use automation scripts**: Leverage provided scripts for common operations
3. **Follow SAFe methodology**: Maintain alignment with existing project structure
4. **Document decisions**: Update project documentation when making workflow changes

## Troubleshooting

### Common Issues

#### Authentication Problems

```bash
# Re-authenticate with GitHub
gh auth logout
gh auth login

# Check token permissions
gh auth status
```

#### Branch Conflicts

```bash
# Resolve merge conflicts
git status
git add resolved_files
git commit -m "TASK-XXX: Resolve merge conflicts"
```

#### Issue Creation Failures

```bash
# Check file format
head -10 project_file.md

# Validate markdown syntax
markdownlint project_file.md
```

### Getting Help

- **GitHub CLI Documentation**: `gh help`
- **Project Management**: See [project-management.mdc](mdc:.cursor/rules/project-management.mdc)
- **Documentation Standards**: See [markdown.mdc](mdc:.cursor/rules/markdown.mdc)

This GitHub integration rule provides comprehensive workflow management that enhances your existing SAFe project structure while maintaining consistency with established coding and documentation standards.
